#include <stdio.h>
#include <string>
#include <string.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/evp.h>
#include <openssl/err.h>
#include "Base64.h"
using namespace std;
using namespace WCDJ;

#define COMM_MAX_BUFLEN 2048


void str2Hex(unsigned char* buf, int& len, string& hex)
{
	for (int i = 0; i < len; ++i)
	{
		char szTmp[3] = {0};
		snprintf(szTmp, sizeof(szTmp), "%02x", buf[i]);
		hex += szTmp;
	}
	printf("sign[%d:%s]\n", len, hex.c_str());
}

// use public.key to verify sign
int verifyRsaSign(const char * szData, const char * szSign, string& strPubKeyPath, int& iResultCode, string& strResultInfo)
{ 
	int iRet = 0;

	FILE *file     =  NULL;
	RSA *rsa       =  NULL;
	EVP_PKEY *pKey =  NULL;

	if ((file = fopen(strPubKeyPath.c_str(), "r")) == NULL)
	{
		iResultCode   =  -1;
		strResultInfo =  "fopen err:" + strPubKeyPath;

		return -1;
	}

	// should include <openssl/pem.h>
	// The default public key file format generated by openssl is the PEM format
	// PEM_read_RSA_PUBKEY() reads the PEM format.
	if ((rsa = PEM_read_RSA_PUBKEY(file, NULL, NULL, NULL)) == NULL)
	{
		iResultCode   =  -2;
		strResultInfo =  "PEM_read_RSA_PUBKEY err";

		fclose(file);
		return -1;
	}

	// should include <openssl/evp.h>
	// private key allocation, EVP_PKEY_free() frees up the private key
	pKey = EVP_PKEY_new();
	if (pKey == NULL)
	{
		iResultCode   =  -3;
		strResultInfo =  "EVP_PKEY_new err";

		RSA_free(rsa);
		fclose(file);
		return -1;
	}

	// should include <openssl/evp.h>
	// set the key referenced by pKey to rsa
	// return 1 for success or 0 for failure
	if (EVP_PKEY_set1_RSA(pKey, rsa) != 1)
	{
		iResultCode   =  -4;
		strResultInfo =  "EVP_PKEY_set1_RSA err";

		RSA_free(rsa);
		EVP_PKEY_free(pKey);
		fclose(file);
		return -1;
	}

	// calc digest
	unsigned char ucDigest[COMM_MAX_BUFLEN] =  {0};
	int iDigest                             =  sizeof(ucDigest);

	// should include <openssl/evp.h>
	// The EVP digest routines are a high level interface to message digests, 
	// and should be used instead of the cipher-specific functions
	EVP_MD_CTX ctx;
	// initializes digest context ctx
	EVP_MD_CTX_init(&ctx);
	EVP_DigestInit(&ctx, EVP_sha1());
	EVP_DigestUpdate(&ctx, szData, strlen(szData));
	EVP_DigestFinal(&ctx, ucDigest, (unsigned int *)&iDigest);


	// decodebase64 sign
	unsigned char ucSign[COMM_MAX_BUFLEN] =  {0};
	int iSign                             =  sizeof(ucSign);

	iSign = DecodeBase64((unsigned char *)szSign, ucSign, COMM_MAX_BUFLEN, strlen(szSign));

	//------------------------------------------
	// debug
	string strSignHex;
	str2Hex(ucSign, iSign, strSignHex);

	string strDigestHex;
	str2Hex(ucDigest, iDigest, strDigestHex);
	//------------------------------------------

	// should include <openssl/rsa.h>
	// RSA_verify() verifies that the signature sigbuf of size siglen matches a given message digest m of size m_len. 
	// type denotes the message digest algorithm that was used to generate the signature. rsa is the signer's public key
	iRet = RSA_verify(NID_sha1, ucDigest, iDigest, ucSign, iSign, rsa);
	if (iRet != 1)
	{
		iResultCode   =  -5;
		strResultInfo =  "RSA_verify err";

		RSA_free(rsa);
		EVP_PKEY_free(pKey);
		fclose(file);
		EVP_MD_CTX_cleanup(&ctx);
		return -1;
	}

	RSA_free(rsa);
	EVP_PKEY_free(pKey);
	fclose(file);
	EVP_MD_CTX_cleanup(&ctx);

	return 0;
}

// use private.key to calc sign
int calcRsaSign(const char * szData, string& strSig, string& strPrivateKeyPath, int& iResultCode, string& strResultInfo)
{
	int iRet = 0;

	FILE *file     =  NULL;
	RSA *rsa       =  NULL;
	EVP_PKEY *pKey =  NULL;

	if ((file = fopen(strPrivateKeyPath.c_str(), "r")) == NULL)
	{
		iResultCode   =  -1;
		strResultInfo =  "fopen err:" + strPrivateKeyPath;

		return -1;
	}

	// should include <openssl/pem.h>
	// The RSAPrivateKey functions process an RSA private key using an RSA structure. 
	// It handles the same formats as the PrivateKey functions but an error occurs if the private key is not RSA.
	if ((rsa = PEM_read_RSAPrivateKey(file, NULL, NULL, NULL)) == NULL)
	{
		iResultCode   =  -2;
		strResultInfo =  "PEM_read_RSA_PUBKEY err";

		fclose(file);
		return -1;
	}

	// should include <openssl/evp.h>
	// private key allocation, EVP_PKEY_free() frees up the private key
	pKey = EVP_PKEY_new();
	if (pKey == NULL)
	{
		iResultCode   =  -3;
		strResultInfo =  "EVP_PKEY_new err";

		RSA_free(rsa);
		fclose(file);
		return -1;
	}

	// should include <openssl/evp.h>
	// set the key referenced by pKey to rsa
	// return 1 for success or 0 for failure
	if (EVP_PKEY_set1_RSA(pKey, rsa) != 1)
	{
		iResultCode   =  -4;
		strResultInfo =  "EVP_PKEY_set1_RSA err";

		RSA_free(rsa);
		EVP_PKEY_free(pKey);
		fclose(file);
		return -1;
	}

	// calc digest
	unsigned char ucDigest[COMM_MAX_BUFLEN] =  {0};
	int iDigest                             =  sizeof(ucDigest);

	// should include <openssl/evp.h>
	// The EVP digest routines are a high level interface to message digests, 
	// and should be used instead of the cipher-specific functions
	EVP_MD_CTX ctx;
	// initializes digest context ctx
	EVP_MD_CTX_init(&ctx);
	EVP_DigestInit(&ctx, EVP_sha1());
	EVP_DigestUpdate(&ctx, szData, strlen(szData));
	EVP_DigestFinal(&ctx, ucDigest, (unsigned int *)&iDigest);

	// calc sign
	int iSign              =  RSA_size(rsa);
	printf("RSA_size(rsa)[%d]\n", iSign);
	unsigned char * ucSign =  (unsigned char *)malloc(sizeof(unsigned char) * iSign);
	memset(ucSign, 0x0, sizeof(unsigned char) * iSign);

#if 0
	iSign = DecodeBase64((unsigned char *)szSign, ucSign, COMM_MAX_BUFLEN, strlen(szSign));
#endif

	// should include <openssl/rsa.h>
	// RSA_sign() signs the message digest m of size m_len using the private key rsa as specified in PKCS #1 v2.0. 
	// It stores the signature in sigret and the signature size in siglen. sigret must point to RSA_size(rsa) bytes of memory. 
	// Note that PKCS #1 adds meta-data, placing limits on the size of the key that can be used. See RSA_private_encrypt(3) for lower-level operations.
	//iRet = RSA_sign(NID_sha1, (unsigned char *)szData, strlen(szData), ucSign, (unsigned int *)&iSign, rsa);
	iRet = RSA_sign(NID_sha1, ucDigest, iDigest, ucSign, (unsigned int *)&iSign, rsa);
	if (iRet != 1)
	{
		iResultCode   =  -5;

		char szErr[1024] = {0};
		ERR_error_string(ERR_get_error(), szErr);
		strResultInfo =  string("RSA_sign err: ") + szErr;

		free(ucSign);
		RSA_free(rsa);
		EVP_PKEY_free(pKey);
		fclose(file);
		EVP_MD_CTX_cleanup(&ctx);
		return -1;
	}

	//------------------------------------------
	// debug
	string strSignHex;
	str2Hex(ucSign, iSign, strSignHex);
	//------------------------------------------

	free(ucSign);
	RSA_free(rsa);
	EVP_PKEY_free(pKey);
	fclose(file);
	EVP_MD_CTX_cleanup(&ctx);

	return 0;
}


int main(int arc, char ** argv)
{
	//string strPublic  =  "./rsakey/public.pem";
	//string strPrivate =  "./rsakey/privatekey.pem";

	string strPublic  =  "./oufei_rsakey/mi_public_key.pem";
	string strPrivate =  "./oufei_rsakey/mi_private_key.pem";

	string strData    =  "too many secrets";

	int iResultCode = 0;
	string strResultInfo;
	int iRet =  0;
	string strSig;

	if ((iRet = calcRsaSign(strData.c_str(), strSig, strPrivate, iResultCode, strResultInfo)) != 0)
	{
		printf("calcRsaSign err[%d:%d:%s]\n", iRet, iResultCode, strResultInfo.c_str());
	}

	return 0;
}
