
后台面试题

-----------------
编程语言部分
-----------------
1，无符号和有符号是否可以比较
不可以，如果有符号的是负数，将类型提升为一个很大的无符号数
2，可以定义一个引用的指针吗
不可以，引用不是对象。
3，虚函数的优缺点
4，深拷贝和浅拷贝的区别
5，堆和栈的区别，在进程虚拟地址空间的位置
6，指向常量的指针，和常量指针分别如何定义
const int * p1 = 1;
int i;
int * const p2 = &i;
7，知道一个递增的区间段，如何计算这个区间段的中位数
比如，3,4,5,6,7
则中位数为：
方法1：(3 + 7) / 2 = 5 溢出问题
方法2：3 + (7 - 3) / 2 = 5 如果是迭代器只能这样用，因为迭代器没有定义加法，只定义了减法
8，函数是否占用对象的空间
9，什么情况下迭代器会失效
10，构造函数的初始值什么情况下必不可少？成员初始化顺序和什么有关？
(1) 如果成员是const，引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。
(2) 构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。
解决方法：最好构造函数初始值的顺序与成员声明的顺序保持一致，而且如果可能的话，尽量避免使用某些成员初始化其他成员。
11，隐士的类类型转换，如何抑制构造函数定义的隐士转换？为什么可以将const char *赋值给string对象？
因为接受一个单参数的const char *的string构造函数不是explicit的。
通过将构造函数声明为explicit来阻止隐士转换。其中，
(1) 关键字explicit只对一个实参的构造函数有效；
(2) 需要多个实参的构造函数不能用于执行隐士转换，所以无须将这些构造函数指定为explicit的；
(3) 只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复；
12，extern "C"的作用
http://blog.csdn.net/delphiwcdj/article/details/7173387
13，使用表达式new失败如何处理？
默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：
int *p1 = new int;           // 如果分配失败，new抛出std::bad_alloc
int *p2 = new (nothrow) int; // 如果分配失败，new返回一个空指针
bad_alloc和nothrow都定义在头文件new中。
14，拷贝构造函数时什么？什么时候使用它？
如果构造函数的第一个参数是自身类类型的引用，且所有其他参数（如果有的话）都有默认值，则此构造函数是拷贝构造函数。拷贝构造函数在以下几种情况下会被使用：
(1) 拷贝初始化(用＝定义变量)；
(2) 将一个对象作为实参传递给非引用类型的行参；
(3) 一个返回类型为非引用类型的函数返回一个对象；
(4) 用花括号列表初始化一个数组中的元素或一个聚合类中的成员；
(5) 初始化标准库容器或调用其insert/push操作时，容器会对其元素进行拷贝初始化； 
15，拷贝赋值运算符是什么？什么时候使用它？合成拷贝赋值运算符完成什么工作？什么时候会生成合成拷贝赋值运算符？
(1) 拷贝赋值运算符本身是一个重载的赋值运算符，定义为类的成员函数，左侧运算对象绑定到隐含的this参数，而右侧运算对象是所属类类型的，作为函数的参数，函数返回指向其左侧运算对象的引用。
(2) 当对类对象进行赋值时，会使用拷贝赋值运算符。
(3) 通常情况下，合成拷贝赋值运算符会将右侧对象的非static成员逐个赋予左侧对象的对应成员，这些赋值操作时由成员类型的拷贝赋值运算符来完成的。
(4) 若一个类未定义自己的拷贝赋值运算符，编译器就会为其合成拷贝赋值运算符，完成赋值操作，但对于某些类，还会起到禁止该类型对象赋值的效果。


-----------------
网络部分
-----------------
1，IP首部和TCP首部分别是多少个字节
20字节，8字节
2，tcp为什么要四次挥手
全双工的协议
3，非阻塞网络编程有哪些方法，select和epoll的区别
4，大小端的定义和判别方法
5，什么情况下socket可读，可写
6，UDP协议和TCP协议的区别
7，TCP协议的粘包问题如何解决

-----------------
Linux系统编程部分
-----------------
1，如何创建一个守护进程
2，一个动态库可以多次dlopen吗
3，如何查看ipc的一些资源
ipcs -a
4，如何查看进程执行的系统调用
strace -pxxx -s1024
5，如何查看进程打开的fd
ls -l /proc/pid/fd
6，一个进程core了如何定位
gdb
7，多进程和多线程的区别
8，Linux虚拟地址空间如何分布？32位和64位有何不同？32/64位操作系统一个进程的虚拟地址空间分别是多少
4G/128T
9，malloc是如何分配内存的？malloc分配多大的内存，就占用多大的物理内存空间吗？free 的内存真的释放了吗（还给 OS ）? 既然堆内内存不能直接释放，为什么不全部使用 mmap 来分配？
10，如何查看进程虚拟地址空间的使用情况？
11，如何查看进程的缺页中断信息？
可通过以下命令查看缺页中断信息
ps -o majflt,minflt -C <program_name>
ps -o majflt,minflt -p <pid>
其中， majflt 代表 major fault ，指大错误， minflt 代表 minor fault ，指小错误。这两个数值表示一个进程自启动以来所发生的缺页中断的次数。其中 majflt 与 minflt 的不同是， majflt 表示需要读写磁盘，可能是内存对应页面在磁盘中需要 load 到物理内存中，也可能是此时物理内存不足，需要淘汰部分物理页面至磁盘中。
如果进程的内核态 CPU 使用过多，其中一个原因就可能是单位时间的缺页中断次数多个，可通过以上命令来查看。
如果 MAJFLT 过大，很可能是内存不足。
如果 MINFLT 过大，很可能是频繁分配 / 释放大块内存 (128k) ， malloc 使用 mmap 来分配。对于这种情况，可通过 mallopt(M_MMAP_THRESHOLD, <SIZE>) 增大临界值，或程序实现内存池。
12，如何查看堆内内存的碎片情况？
13，除了glibc的malloc/free ，还有其他第三方实现吗？

-----------------
数据库部分
-----------------
1，mysql_use_result和mysql_store_result的区别





