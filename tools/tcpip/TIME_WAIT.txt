

在内核协议层通过设置以下两个参数来解决TIME_WAIT问题： 
  1. TIME_WAIT状态可以重用，这样即使TIME_WAIT占满了所有端口，也不会拒绝新的请求
     echo 1 > /proc/sys/net/ipv4/tcp_tw_reuse 
  2. TIME_WAIT尽快回收
       echo 1 > /proc/sys/net/ipv4/tcp_tw_recycle
  其实只修改tcp_tw_recycle就可以解决问题，TIME_WAIT重用TCP协议本身是不建议打开的。tcp_tw_recycle打开后能在很短的时间能将TIME_WAIT的端口回收（但是具体时间并未找到相应的资料，测试观察在1秒左右）。同时，打开加速回收或者允许重用，存在一定的问题，例如，发起方(client)在发出最后一个ACK后立即被回收，而ACK丢失，接受方超时重发FIN，恰好此时发起方使用刚才的端口建立起新的连接，那它将收到一个FIN，从而可能引发异常被动关闭。
  与TIME_WAIT相对应的是CLOSE_WAIT问题，被动关闭的情况下，已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。正常情况下CLOSE_WAIT状态时间很短。如果出现大量的CLOSE_WAIT，是某种情况下对方关闭了链接，但是接受方忙与读或者写，没有关闭连接导致。在代码实现的时候需要判断socket，一旦read返回0，断开连接，read返回负，检查一下errno，如果不是AGAIN，也断开连接。


