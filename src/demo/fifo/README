
常用的FIFO通信模式


1, client阻塞写，svr阻塞读

(1) 系统规定：在一个以O_WRONLY方式(即阻塞写方式)打开的FIFO中，如果写入的数据长度小于等于PIPE_BUF，那么或者写入全部字节，或者一个字节都不写入。
(2) 假设生产者/写进程先启动，它将阻塞以等待消费者/读进程打开这个FIFO，当消费者/读进程启动后，写进程解除阻塞并开始向管道写数据，同时，消费者/读进程也开始从管道中读取数据。Linux会安排好这两个进程之间的调度，使它们在可以运行的时候运行，在不能运行的时候阻塞。因此，生产者/写进程将在管道满时阻塞，消费者/读进程将在管道空时阻塞。
(3) 多个client阻塞写，svr阻塞读的场景模式：
client1 -> fifo_req -> svr, client1 <- fifo_client1 <- svr
client2 -> fifo_req -> svr, client2 <- fifo_client2 <- svr
client3 -> fifo_req -> svr, client3 <- fifo_client3 <- svr
假设每个client发送完数据后都会close fifo_req，那么直到最后一个客户关闭服务器管道为止，这将使服务器的read调用失败(返回0)，因为已经没有进程以写的方式打开服务器管道了。因此作为svr端，需要继续等待client的请求，可以通过下面两个方法：
[1] 对它自己的服务器管道打开一个文件描述符，这样read调用将总是阻塞而不是返回0。
[2] 当read调用返回0时，关闭并重新打开服务器管道，是服务器进程阻塞在open调用处以等待客户的到来，就像它最迟启动那样。


2, client异步写，svr阻塞读


